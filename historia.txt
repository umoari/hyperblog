Esta es la historia de Ariel Ureña por el mundo de la programación.

Ariel empezó a estudiar en Platzi hace dos meses y ha terminado algunos cursos hasta la fecha.

En Junio, tras haber terminado el curso de Responsive Design, ahora se adentra en el maravilloso mundo de Git.

Al principio, se sentía intimidado por un software del que no sabía nada, pero poco a poco comenzó a entenderlo mejor.

Ya ha practicado mucho algunos comandos de Git, son muchos (como los pokemones), hasta ahora ya sabe usar:
git init *dentro de nuestra carpeta de trabajo
git add *nombreArchivo.extension 
git add *. para agregar todos los archivos dentro de la carpeta
git status
git commit

git log
git log --stat (muestra los stats de los cambios hechos)
git diff hashVersion hashVersion

git reset hashSHA-1 --hard/--soft (para volver a una version anterior)
git checkout hashSHA-1 archivo.extension (visualizar una version segun su hashSHA-1)
git checkout master archivo.extension (volver a la version mas actualizada del archivo)

Con estos comandos, Ariel ya sabe inicializar Git, agregar archivos al repositorio, revisar el estado de Git y guardar cambios.

Con git log y log --stat, Ariel ya aprendio a  revisar el historial dentro de Git y ver las estadisticas de los cambios.
Con git diff hashVersion hashVersion, Ariel aprendió a visualizar las diferencias entre dos versiones.

Ahora, está aprendiendo el comando git reset hashSHA-1 --hard/--soft para volver a una versión anterior dentro del repositorio según el hash SHA-1 designado.
Con git checkout hashSHA-1 archivo.extension se puede visualizar el archivo en una de sus versiones anteriores según el hash SHA-1 seleccionado, sólo se regresa a la versión pero no se guardan los cambios.
Si se quiere volver a la versión más actualizada, se puede utilizar git checkout master archivo.extension.

Cuando en la pantalla hay mas cambios que los que caben en la ventana, podemos salirnos del listado con Q.

**Fljo de trabajo con Git**
Ya vimos que para trabajar con Git de manera local tenemos 3 áreas: nuestro directorio de trabajo, nuestra área de staging y nuestro repositorio local.
De forma local, el fluo de trabajo es agregar un archivo a staging con git add y luego guardar los cambios con git commit.

De forma remota, el flujo de trabajo no es muy diferente. Primero hay que clonar el repositorio de trabajo con git clone url.
Una vez clonado el repositorio, tenemos en nuestro equipo local el directorio de trabajo, el área de staging y el repositorio local.
El flujo de trabajo es muy parecido: agregamos archivos a staging con git add, los guardamos con git commit y luego los enviamos al repositorio remoto con git push.
git fetch copia a nuestro repositorio local las actualizaciones de la base de datos del repositorio remoto.
git merge copia a nuestro repositorio local los archivos actualizados del servidor remoto.
git pull cumple con las funciones de git fetch y git pull al mismo tiempo.

git clone url
git push
git fetch
git merge
git pull

**Introducción a las ramas o branches de Git**
Antes de comenzar a aprender sobre el uso de ramas, primero hagamos cambios a nuestros archivos.
Después de haber cambiado podemos hacer commit con nuevos argumentos:

git commit -a (Se hace commit a los archivos existentes y que tengan cambios)
git commit -am (Se junta la función de git commit -a y -m)

¿Cómo creamos ramas?
Es importante mencionar que las ramas se crean en el lugar donde nos encontramos, podemos verlo con git status.
Para crear una rama en Git utilizamos el comando git branch (nombre de la rama).
Para cambiarnos de una rama a otra utilizamos git checkout (nombre de la rama).

git branch (nombre de la rama)
git checkout (nombre de la rama)

--Recordemos que en VIM podemos salir y guardar con esc shift z z.

--Tambien es importante recordar que cada vez que nos cambiamos de una rama a otra, el archivo se queda en la versión HEAD de cada rama.

**Fusion de ramas con Git merge**
Seguimos con nuestro repositorio de trabajo. Vamos a hacer algunos cambios a index.html dentro de la rama master.
Después vamos a hacer algunos cambios de index.html y styles.css dentro de la rama cabecera.
Tras haber hecho esto, vamos a unirlos a ver qué pasa con nuestros archivos.

--Es importante señalar que cuando usamos git merge la rama desaparece y se integra a la rama principal. Más adelante podemos desglosar más ramas a master y seguir haciendo merge.
